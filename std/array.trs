import "core.trs"
// basically a vector type
fn offsetof(array.data)     : number do 2 end
fn offsetof(array.count)    : number do 1 end
fn offsetof(array.capacity) : number do 0 end

fn cast(array) any : array do end

fn array:new : array do 
    3 memalloc
    let ptr do 
        1 memalloc ptr offsetof(array.data) ptr+ !ptr
        0 ptr offsetof(array.count) ptr+ !num
        1 ptr offsetof(array.capacity) ptr+ !num

        ptr
    end
    cast(array)
end

fn array:free array : do
    cast(ptr)
    let ptr do
        ptr offsetof(array.data) ptr+ @ptr memfree
        ptr memfree
    end
end

fn array.count array : number do
    cast(ptr) offsetof(array.count) ptr+ @num
end
fn array.capacity array : number do
    cast(ptr) offsetof(array.capacity) ptr+ @num
end
fn array.data array : ptr do
    cast(ptr) offsetof(array.data) ptr+ @ptr
end

fn array:nth number array : any do
    let nth array do
        nth array array.count >= if
            "error [array:nth]: nth number is greater than array count" prn
            1 exit
        end
        array array.data nth ptr+ @
    end
end

fn array:push any array : do
    let value arr do
        arr array.count arr array.capacity >= if
            // not enough space allocated
            arr array.data arr array.capacity arr array.capacity 2 * realloc
            arr cast(ptr) offsetof(array.capacity) ptr+ @num 2 * arr cast(ptr) offsetof(array.capacity) ptr+ !num
            arr cast(ptr) offsetof(array.data) ptr+ !ptr
        end
        value arr array.data arr array.count ptr+ !
        arr cast(ptr) offsetof(array.count) ptr+ ptr-inc
    end
end

fn array:pop array : any do
    let arr do
        arr array.count 0 < if
            "error [array:pop]: no elements in array" prn
            1 exit
        end
        arr array.count 1 - arr array:nth
        arr cast(ptr) offsetof(array.count) ptr+ ptr-dec
    end
end